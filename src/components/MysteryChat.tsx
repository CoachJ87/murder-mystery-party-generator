
import React, { useState, useRef, useEffect } from 'react';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import { Card, CardHeader, CardContent, CardDescription } from "@/components/ui/card";
import { toast } from "sonner";
import { Send, Loader2, Zap } from "lucide-react";
import { useIsMobile } from "@/hooks/use-mobile";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Separator } from "@/components/ui/separator";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Slider } from "@/components/ui/slider";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import { cn } from "@/lib/utils";
import { useAuth } from "@/context/AuthContext";
import { Message } from "@/components/types";
import { supabase } from "@/lib/supabase";

interface MysteryChatProps {
  initialTheme?: string;
  initialPlayerCount?: number;
  initialHasAccomplice?: boolean;
  initialScriptType?: 'full' | 'pointForm';
  initialAdditionalDetails?: string;
  savedMysteryId?: string;
  onSave: (message: Message) => Promise<void>;
  onGenerateFinal?: (messages: Message[]) => Promise<void>;
  initialMessages?: Message[];
  isLoadingHistory?: boolean;
  systemInstruction?: string;
  preventDuplicateMessages?: boolean;
  skipForm?: boolean;
}

const formSchema = z.object({
  theme: z.string().min(2, {
    message: "Theme must be at least 2 characters.",
  }).max(50, {
    message: "Theme must not be longer than 50 characters.",
  }),
  playerCount: z.number().min(2, {
    message: "Must have at least 2 players"
  }).max(20, {
    message: "Must not have more than 20 players"
  }),
  hasAccomplice: z.boolean().default(false),
  scriptType: z.enum(['full', 'pointForm']).default('full'),
  additionalDetails: z.string().max(500).optional(),
});

export default function MysteryChat({
  initialTheme,
  initialPlayerCount,
  initialHasAccomplice,
  initialScriptType,
  initialAdditionalDetails,
  savedMysteryId,
  onSave,
  onGenerateFinal,
  initialMessages = [],
  isLoadingHistory = false,
  systemInstruction,
  preventDuplicateMessages = false,
  skipForm = false
}: MysteryChatProps) {
  const [input, setInput] = useState('');
  const [messages, setMessages] = useState<Message[]>([]);
  const [isAiTyping, setIsAiTyping] = useState(false);
  const [currentTheme, setCurrentTheme] = useState(initialTheme || '');
  const [currentPlayerCount, setCurrentPlayerCount] = useState(initialPlayerCount || 4);
  const [currentHasAccomplice, setCurrentHasAccomplice] = useState(initialHasAccomplice || false);
  const [currentScriptType, setCurrentScriptType] = useState(initialScriptType || 'full');
  const [currentAdditionalDetails, setCurrentAdditionalDetails] = useState(initialAdditionalDetails || '');
  const { isAuthenticated } = useAuth();
  const isMobile = useIsMobile();
  const bottomRef = useRef<HTMLDivElement>(null);

  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      theme: initialTheme || "",
      playerCount: initialPlayerCount || 4,
      hasAccomplice: initialHasAccomplice || false,
      additionalDetails: initialAdditionalDetails || "",
    },
    mode: "onChange"
  });

  // Helper function to ensure proper timestamp handling
  const ensureValidTimestamp = (message: any): Message => {
    let timestamp: Date;
    
    if (message.timestamp) {
      timestamp = message.timestamp instanceof Date ? message.timestamp : new Date(message.timestamp);
    } else if (message.created_at) {
      timestamp = new Date(message.created_at);
    } else {
      timestamp = new Date();
    }

    return {
      id: message.id || Date.now().toString(),
      content: message.content || '',
      is_ai: message.is_ai !== undefined ? message.is_ai : (message.role === 'assistant'),
      timestamp: timestamp,
      isAutoGenerated: message.isAutoGenerated || false
    };
  };

  useEffect(() => {
    const processedMessages = initialMessages.map(ensureValidTimestamp);
    setMessages(processedMessages);
  }, [initialMessages]);

  useEffect(() => {
    if (initialTheme) {
      form.setValue("theme", initialTheme);
      setCurrentTheme(initialTheme);
    }
    if (initialPlayerCount) {
      form.setValue("playerCount", initialPlayerCount);
      setCurrentPlayerCount(initialPlayerCount);
    }
    if (initialHasAccomplice) {
      form.setValue("hasAccomplice", initialHasAccomplice);
      setCurrentHasAccomplice(initialHasAccomplice);
    }
    if (initialScriptType) {
      setCurrentScriptType(initialScriptType);
    }
    if (initialAdditionalDetails) {
      form.setValue("additionalDetails", initialAdditionalDetails);
      setCurrentAdditionalDetails(initialAdditionalDetails);
    }
  }, [initialTheme, initialPlayerCount, initialHasAccomplice, initialScriptType, initialAdditionalDetails, form]);

  useEffect(() => {
    bottomRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages, isAiTyping]);

  const createSystemMessage = (data: any) => {
    let systemMsg = "You are a helpful mystery writer. Your job is to help the user create an exciting murder mystery game.";
    systemMsg += `\nThe user wants to create a murder mystery with theme: ${data.theme}. `;
    systemMsg += `The user wants to create a murder mystery with ${data.playerCount} players. `;
    systemMsg += `The user wants to create a murder mystery with ${data.hasAccomplice ? 'an' : 'no'} accomplice. `;
    systemMsg += `The user wants to create a murder mystery with a ${data.scriptType} script. `;
    if (data.additionalDetails) {
      systemMsg += `The user wants to create a murder mystery with the following additional details: ${data.additionalDetails}. `;
    }
    return systemMsg;
  };

  const handleSendMessage = async (content: string) => {
    if (!content.trim()) return;

    setInput('');

    const userMessage: Message = {
      id: Date.now().toString(),
      content: content.trim(),
      is_ai: false,
      timestamp: new Date(),
      isAutoGenerated: false
    };

    const newMessages = [...messages, userMessage];
    setMessages(newMessages);

    try {
      await onSave(userMessage);
    } catch (error) {
      console.error("Error saving user message:", error);
    }

    setIsAiTyping(true);

    try {
      console.log("=== Starting AI Request ===");
      console.log("User message:", content);
      console.log("Current conversation length:", newMessages.length);
      
      const systemPrompt = systemInstruction || createSystemMessage({
        theme: currentTheme,
        playerCount: currentPlayerCount,
        hasAccomplice: currentHasAccomplice,
        scriptType: currentScriptType,
        additionalDetails: currentAdditionalDetails
      });

      console.log("System prompt being sent:", systemPrompt.substring(0, 200) + "...");

      // Use the Supabase function directly
      const { data, error } = await supabase.functions.invoke('mystery-ai', {
        body: {
          messages: newMessages.map(msg => ({
            role: msg.is_ai ? "assistant" : "user",
            content: msg.content
          })),
          system: systemPrompt,
          promptVersion: 'free'
        }
      });

      if (error) {
        throw new Error(`Supabase function error: ${error.message}`);
      }

      console.log("=== AI Response Received ===");
      console.log("Response data:", data);

      if (data && data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) {
        const aiResponse = data.choices[0].message.content;
        console.log("AI response content:", aiResponse);

        const aiMessage: Message = {
          id: (Date.now() + 1).toString(),
          content: aiResponse,
          is_ai: true,
          timestamp: new Date(),
          isAutoGenerated: false
        };

        const updatedMessages = [...newMessages, aiMessage];
        setMessages(updatedMessages);

        try {
          await onSave(aiMessage);
        } catch (error) {
          console.error("Error saving AI message:", error);
        }
      } else {
        throw new Error('Invalid response format from AI service');
      }
    } catch (error) {
      console.error('Error calling AI service:', error);
      toast.error("Failed to get AI response. Please try again.");
      
      const errorMessage: Message = {
        id: (Date.now() + 1).toString(),
        content: "I apologize, but I'm having trouble responding right now. Please try again in a moment.",
        is_ai: true,
        timestamp: new Date(),
        isAutoGenerated: false
      };

      setMessages([...newMessages, errorMessage]);
      
      // Still try to save the error message so conversation flow is maintained
      try {
        await onSave(errorMessage);
      } catch (saveError) {
        console.error("Error saving AI error message:", saveError);
      }
    } finally {
      setIsAiTyping(false);
    }
  };

  return (
    <div className="flex flex-col h-full space-y-6">
      {!skipForm && (
        <Card className="mb-4">
          <CardHeader>
            <Label className="text-lg">Mystery Settings</Label>
            <CardDescription>
              Configure the basic settings for your murder mystery.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <Form {...form}>
              <form className="space-y-4">
                <FormField
                  control={form.control}
                  name="theme"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Theme</FormLabel>
                      <FormControl>
                        <Input
                          placeholder="e.g. Roaring 20s, Space Station"
                          {...field}
                          onChange={(e) => {
                            field.onChange(e);
                            setCurrentTheme(e.target.value);
                          }}
                        />
                      </FormControl>
                      <FormDescription>
                        The overall theme or setting for your mystery.
                      </FormDescription>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="playerCount"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Player Count</FormLabel>
                      <FormControl>
                        <Input
                          type="number"
                          placeholder="4"
                          {...field}
                          onChange={(e) => {
                            const value = parseInt(e.target.value);
                            if (!isNaN(value)) {
                              field.onChange(value);
                              setCurrentPlayerCount(value);
                            }
                          }}
                        />
                      </FormControl>
                      <FormDescription>
                        The number of players that will be participating in the
                        mystery.
                      </FormDescription>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="hasAccomplice"
                  render={({ field }) => (
                    <FormItem className="flex flex-row items-center justify-between rounded-lg border p-4">
                      <div className="space-y-0.5">
                        <FormLabel>Accomplice</FormLabel>
                        <FormDescription>
                          Should the murderer have an accomplice?
                        </FormDescription>
                      </div>
                      <FormControl>
                        <Switch
                          checked={field.value}
                          onCheckedChange={(checked) => {
                            field.onChange(checked);
                            setCurrentHasAccomplice(checked);
                          }}
                        />
                      </FormControl>
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="additionalDetails"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Additional Details</FormLabel>
                      <FormControl>
                        <Textarea
                          placeholder="Any additional details you want to include?"
                          className="resize-none"
                          {...field}
                          onChange={(e) => {
                            field.onChange(e);
                            setCurrentAdditionalDetails(e.target.value);
                          }}
                        />
                      </FormControl>
                      <FormDescription>
                        Any additional details you want to include?
                      </FormDescription>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              </form>
            </Form>
          </CardContent>
        </Card>
      )}

      {/* Chat Container */}
      <div className="border rounded-lg bg-background">
        {/* Chat Messages Area */}
        <div className="h-96 overflow-y-auto p-4 space-y-3">
          {isLoadingHistory && (
            <div className="text-center text-muted-foreground">
              <Loader2 className="h-6 w-6 animate-spin mx-auto mb-2" />
              Loading previous messages...
            </div>
          )}
          
          {messages.map((message) => (
            <div
              key={message.id}
              className={cn(
                "flex",
                message.is_ai ? "justify-start" : "justify-end"
              )}
            >
              <div
                className={cn(
                  "max-w-[80%] rounded-lg px-4 py-2",
                  message.is_ai
                    ? "bg-muted border"
                    : "bg-primary text-primary-foreground"
                )}
              >
                <p className="text-sm whitespace-pre-line">{message.content}</p>
              </div>
            </div>
          ))}
          
          {isAiTyping && (
            <div className="flex justify-start">
              <div className="bg-muted border rounded-lg px-4 py-2 max-w-[80%]">
                <div className="flex space-x-1">
                  <div className="h-2 w-2 bg-muted-foreground rounded-full animate-bounce" style={{ animationDelay: "0ms" }}></div>
                  <div className="h-2 w-2 bg-muted-foreground rounded-full animate-bounce" style={{ animationDelay: "150ms" }}></div>
                  <div className="h-2 w-2 bg-muted-foreground rounded-full animate-bounce" style={{ animationDelay: "300ms" }}></div>
                </div>
              </div>
            </div>
          )}
          <div ref={bottomRef} />
        </div>

        {/* Chat Input Area */}
        <div className="border-t p-4">
          <div className="flex items-center space-x-2">
            <Input
              type="text"
              placeholder="Type your message..."
              value={input}
              onChange={(e) => setInput(e.target.value)}
              onKeyDown={(e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                  e.preventDefault();
                  handleSendMessage(input);
                }
              }}
              disabled={isAiTyping}
              className="flex-grow"
            />
            <Button 
              type="submit" 
              onClick={() => handleSendMessage(input)} 
              disabled={isAiTyping}
              size="icon"
            >
              {isAiTyping ? <Loader2 className="h-4 w-4 animate-spin" /> : <Send className="h-4 w-4" />}
            </Button>
          </div>
        </div>
      </div>
      
      {/* Generate Final Mystery Button */}
      {onGenerateFinal && messages.length > 0 && (
        <Button
          onClick={() => onGenerateFinal(messages)}
          className="w-full bg-red-600 hover:bg-red-700"
          size="lg"
        >
          <Zap className="mr-2 h-5 w-5" />
          Generate Final Mystery
        </Button>
      )}
    </div>
  );
}
